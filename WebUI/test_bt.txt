// play_linux_har_all_fxblotter_final.js
// FX Blotter validation with HAR + Screenshot + JSON summary
// Enhanced: after blotter loads, pick first two visible order IDs, open their charts, screenshot each and copy HAR snapshot.
// Now also sends email via s-nail: always attachments screenshot; on failure attach HAR + JSON + chart captures.
//
// Usage examples:
//   MERCURY_USER=... MERCURY_PASS=... EMAIL_TO="support@example.lab" node play_linux_har_all_fxblotter_final.js
//   MERCURY_USER=... MERCURY_PASS=... BLOTTER_TIMEOUT_MS=20000 MIN_ROWS=10 OUTDIR=/projects/logs node play_linux_har_all_fxblotter_final.js --headed
//
// Environment variables:
//   EMAIL_MTA (default: smtp://smtp.example.lab:55)
//   EMAIL_FROM (default: alert@example.lab)
//   EMAIL_TO (comma separated, default: support@example.lab)
//   EMAIL_SUBJECT_PREFIX (optional)
//   SEND_EMAIL (set to "false" to disable sending)
//   OUTDIR (output dir, default: .)
//   Others: MERCURY_USER, MERCURY_PASS, BLOTTER_TIMEOUT_MS, MIN_ROWS
//
// Note: script assumes 's-nail' binary is installed and supports '-a' attachment flag. Adjust sendEmail() if your variant differs.

const { chromium } = require('playwright');
const fs = require('fs');
const path = require('path');
const os = require('os');
const { spawnSync } = require('child_process');

const sleep = ms => new Promise(r => setTimeout(r, ms));
const headed = process.argv.includes('--headed');

const launchOptions = {
  headless: !headed,
  args: ['--no-sandbox', '--disable-setuid-sandbox']
};
if (headed) launchOptions.args.unshift('--start-maximized');

const OUTROOT = process.env.OUTDIR || '.';
const PAGE_NAME = 'FX_Blotter';
const PAGE_DIR = path.join(OUTROOT, 'logs', PAGE_NAME.toLowerCase());
fs.mkdirSync(PAGE_DIR, { recursive: true });

function tsName(status, ext = 'png') {
  const d = new Date();
  const Y = d.getFullYear(), M = String(d.getMonth() + 1).padStart(2, '0');
  const D = String(d.getDate()).padStart(2, '0');
  const T = Date.now();
  return `${PAGE_NAME}_${status}_${Y}_${M}_${D}_${T}.${ext}`;
}

/**
 * Send an email using s-nail (synchronous).
 * - EMAIL_MTA: smtp://...
 * - EMAIL_FROM: from address
 * - EMAIL_TO: comma separated recipients
 * - EMAIL_SUBJECT_PREFIX: optional prefix
 * - SEND_EMAIL=false to skip sending (string "false")
 *
 * attachments: array of absolute file paths
 */
function sendEmail(subject, body, attachments = []) {
  try {
    if (process.env.SEND_EMAIL && process.env.SEND_EMAIL.toLowerCase() === 'false') {
      console.log('sendEmail: disabled via SEND_EMAIL=false');
      return;
    }

    const mta = process.env.EMAIL_MTA || 'smtp://smtp.example.lab:55';
    const from = process.env.EMAIL_FROM || 'alert@example.lab';
    const toEnv = process.env.EMAIL_TO || 'support@example.lab';
    const to = toEnv.split(',').map(s => s.trim()).filter(Boolean);
    if (!to.length) {
      console.warn('sendEmail: no recipients configured (EMAIL_TO empty). Skipping email.');
      return;
    }
    const subjectPrefix = process.env.EMAIL_SUBJECT_PREFIX ? `${process.env.EMAIL_SUBJECT_PREFIX} ` : '';
    const finalSubject = `${subjectPrefix}${subject}`;

    const args = [
      '-v',
      '-S', `mta=${mta}`,
      '-S', `from=${from}`,
      '-S', 'smtp-auth=non',
      '-s', finalSubject
    ];

    // Attach files if they exist (s-nail supports -a)
    for (const a of attachments) {
      try {
        if (a && fs.existsSync(a)) args.push('-a', a);
        else if (a) console.warn(`sendEmail: attachment missing, skipping: ${a}`);
      } catch (e) {
        console.warn(`sendEmail: could not stat attachment ${a}:`, e && e.message);
      }
    }

    args.push(...to);

    console.log('sendEmail: running s-nail', args.join(' '));
    const res = spawnSync('s-nail', args, {
      input: body,
      encoding: 'utf8',
      maxBuffer: 20 * 1024 * 1024 // 20MB
    });

    if (res.error) {
      console.error('sendEmail: spawn error', res.error);
    } else {
      console.log('sendEmail: exitCode=', res.status);
      if (res.stdout) console.log('s-nail stdout:', res.stdout.trim().slice(0, 800));
      if (res.stderr) console.log('s-nail stderr:', res.stderr.trim().slice(0, 800));
      if (res.status !== 0) {
        console.error('sendEmail: non-zero exit from s-nail', res.status);
      }
    }
  } catch (e) {
    console.error('sendEmail exception:', e && (e.stack || e.message || e));
  }
}

(async () => {
  const username = process.env.MERCURY_USER || 'username';
  const password = process.env.MERCURY_PASS || 'pass1word';

  const tmpHar = path.join(os.tmpdir(), `play_har_${Date.now()}.har`);
  const browser = await chromium.launch(launchOptions);

  const context = await browser.newContext({
    viewport: headed ? null : { width: 1280, height: 800 },
    recordHar: { path: tmpHar }
  });

  const page = await context.newPage();

  let finalScreenshotPath = null;
  let finalHarPath = null;
  let finalJsonPath = null;
  let chartResults = []; // populated if success

  try {
    await page.goto('https://markets.ml.com/fx/blotter', { waitUntil: 'domcontentloaded', timeout: 60000 });
    await sleep(2500);

    // Handle cookie banners (robust list)
    const cookieSelectors = [
      '#onetrust-accept-btn-handler',
      'text="Accept All Optional Cookies"',
      'text="Allow All"',
      'button:has-text("Accept All Optional Cookies")',
      'button:has-text("Allow All")'
    ];
    for (const sel of cookieSelectors) {
      try {
        const loc = page.locator(sel);
        if (await loc.count() > 0 && await loc.first().isVisible()) {
          await loc.first().click({ force: true }).catch(() => loc.first().evaluate(e => e && e.click()));
          await sleep(1000);
          break;
        }
      } catch {}
    }

    // Login if fields visible
    const uSel = 'input[placeholder*="user" i], input[name="username"], input[id*="user"], input[type="text"]';
    const pSel = 'input[placeholder*="password" i], input[name="password"], input[id*="pass"], input[type="password"]';
    const hasLogin = await page.locator(`${uSel}, ${pSel}`).count() > 0;
    if (hasLogin) {
      try {
        await page.waitForSelector(uSel, { timeout: 15000 });
        await page.waitForSelector(pSel, { timeout: 15000 });

        const userLoc = page.locator(uSel).first();
        const passLoc = page.locator(pSel).first();

        await userLoc.click({ clickCount: 3 }).catch(() => {});
        await userLoc.fill('');
        await userLoc.type(username, { delay: 40 });

        await passLoc.click({ clickCount: 3 }).catch(() => {});
        await passLoc.fill('');
        await passLoc.type(password, { delay: 40 });

        const loginBtn = page.getByRole('button', { name: /log\s*in|sign\s*in/i }).first();
        if (await loginBtn.count() > 0 && await loginBtn.first().isVisible()) {
          await loginBtn.first().click({ timeout: 5000 }).catch(() => page.keyboard.press('Enter'));
        } else {
          const fallback = page.locator('button[type="submit"], input[type="submit"], button[id*="login"], button[class*="login"]').first();
          if (await fallback.count() > 0 && await fallback.isVisible()) {
            await fallback.click({ timeout: 5000 }).catch(() => page.keyboard.press('Enter'));
          } else {
            await page.keyboard.press('Enter');
          }
        }
      } catch (e) {}
    }

    await sleep(3500);

    // --- FX Blotter logic ---
    const BLOTTER_TIMEOUT_MS = Number(process.env.BLOTTER_TIMEOUT_MS || 15000);
    const MIN_ROWS = Number(process.env.MIN_ROWS || 15);
    const deadline = Date.now() + BLOTTER_TIMEOUT_MS;

    const dataRowSelectors = ['.ui-grid-row', 'table tbody tr', '.grid-row', '.blotter-row', '.fx-row'];
    const watermarkText = 'No data available';
    const spinnerSelectors = ['.fa-spinner', '.spinner', '.loading', '.loader', '.busy', 'div[role="status"]'];

    let success = false;
    let rowsFound = 0;
    let reason = null;

    // Fail immediately if watermark appears
    try {
      const wmLoc = page.locator(`text="${watermarkText}"`);
      if (await wmLoc.count() > 0 && await wmLoc.first().isVisible()) {
        reason = `"${watermarkText}" text visible on page`;
      }
    } catch (e) {}

    while (Date.now() < deadline && !success && reason === null) {
      let visibleRowCount = 0;
      for (const sel of dataRowSelectors) {
        const loc = page.locator(sel);
        const c = await loc.count();
        if (c === 0) continue;
        for (let i = 0; i < c; i++) {
          const row = loc.nth(i);
          if (!await row.isVisible()) continue;
          const txt = (await row.innerText()).trim();
          if (!txt || txt.toLowerCase().includes(watermarkText.toLowerCase())) continue;
          if (/\d/.test(txt) || /USD|EUR|GBP|JPY/i.test(txt)) {
            visibleRowCount++;
          }
        }
      }

      rowsFound = visibleRowCount;
      if (visibleRowCount >= MIN_ROWS) {
        success = true;
        reason = `Found ${rowsFound} valid blotter rows (≥ ${MIN_ROWS})`;
        break;
      }

      await sleep(500);
    }

    if (!success && reason === null) {
      let spinnerVisible = false;
      try {
        for (const s of spinnerSelectors) {
          const loc = page.locator(s);
          if (await loc.count() > 0 && await loc.first().isVisible()) {
            spinnerVisible = true;
            break;
          }
        }
      } catch (e) {}
      reason = spinnerVisible
        ? 'Timeout: spinner visible after wait (possible entitlement/service issue)'
        : `Timeout: only ${rowsFound} row(s) found (< ${MIN_ROWS})`;
    }

    // Base screenshot of blotter
    const status = success ? 'Success' : 'Failed';
    const shotName = tsName(status, 'png');
    finalScreenshotPath = path.join(PAGE_DIR, shotName);
    await page.screenshot({ path: finalScreenshotPath, fullPage: true });

    // If success, attempt to find first two order IDs and capture their charts
    chartResults = [];
    if (success) {
      const orderIdLoc = page.locator('text=/\\d{5,}/');
      const foundIds = [];
      const maxCandidates = 50;
      const totalCandidates = Math.min(await orderIdLoc.count(), maxCandidates);
      for (let i = 0; i < totalCandidates && foundIds.length < 10; i++) {
        try {
          const el = orderIdLoc.nth(i);
          if (!await el.isVisible()) continue;
          const text = (await el.innerText()).trim();
          const m = text.match(/\d{5,}/);
          if (m) {
            const id = m[0];
            if (!foundIds.includes(id)) foundIds.push(id);
          }
        } catch (e) { /* continue */ }
      }

      if (foundIds.length === 0) {
        const altSelectors = ['.order-id', '.orderId', 'td.order, td[data-order-id]', 'a[href*="order"]', 'a[data-order-id]'];
        for (const sel of altSelectors) {
          try {
            const loc = page.locator(sel);
            const c = Math.min(await loc.count(), 50);
            for (let i = 0; i < c && foundIds.length < 10; i++) {
              try {
                const el = loc.nth(i);
                if (!await el.isVisible()) continue;
                const txt = (await el.innerText()).trim();
                const m = txt.match(/\d{5,}/);
                if (m) {
                  const id = m[0];
                  if (!foundIds.includes(id)) foundIds.push(id);
                }
              } catch {}
            }
            if (foundIds.length) break;
          } catch {}
        }
      }

      const toCapture = foundIds.slice(0, 2);
      for (const orderId of toCapture) {
        let chartShot = null;
        let chartHarCopy = null;
        let note = null;
        try {
          const clickable = page.locator(`text="${orderId}"`);
          if (await clickable.count() > 0 && await clickable.first().isVisible()) {
            await clickable.first().click({ timeout: 5000 }).catch(() => clickable.first().evaluate(e => e && e.click()));
          } else {
            const rowCandidate = page.locator(`:text("${orderId}")`).locator('xpath=ancestor::tr').first();
            if (await rowCandidate.count() > 0 && await rowCandidate.isVisible()) {
              await rowCandidate.click().catch(() => {});
            } else {
              const linkByHref = page.locator(`a[href*="${orderId}"]`).first();
              if (await linkByHref.count() > 0 && await linkByHref.isVisible()) {
                await linkByHref.click().catch(() => {});
              } else {
                await page.locator(`text="${orderId}"`).first().dblclick().catch(() => {});
              }
            }
          }

          const chartSelectors = [
            '.cumulative-fills',
            '.order-chart', '.chart', '#orderChart', '.chart-container', '.trade-chart', '.chart-svg'
          ];
          let chartFound = false;
          const chartDeadline = Date.now() + 15000;
          let chartLocator = null;
          while (Date.now() < chartDeadline && !chartFound) {
            for (const cs of chartSelectors) {
              try {
                const cl = page.locator(cs).first();
                if (await cl.count() > 0 && await cl.isVisible()) {
                  chartFound = true;
                  chartLocator = cl;
                  break;
                }
              } catch {}
            }
            if (!chartFound) await sleep(500);
          }

          if (chartFound && chartLocator) {
            const shotFile = tsName(`Chart_${orderId}`, 'png');
            chartShot = path.join(PAGE_DIR, shotFile);
            try {
              await chartLocator.screenshot({ path: chartShot });
            } catch (e) {
              await page.screenshot({ path: chartShot, fullPage: false });
            }
            note = 'Chart element captured';
          } else {
            const shotFile = tsName(`Chart_${orderId}_fullpage`, 'png');
            chartShot = path.join(PAGE_DIR, shotFile);
            await page.screenshot({ path: chartShot, fullPage: true });
            note = 'Chart not found by selectors; full-page screenshot saved';
          }

          const harFile = tsName(`Chart_${orderId}`, 'har');
          chartHarCopy = path.join(PAGE_DIR, harFile);
          try {
            if (fs.existsSync(tmpHar)) {
              fs.copyFileSync(tmpHar, chartHarCopy);
            } else {
              fs.writeFileSync(chartHarCopy, JSON.stringify({ log: { entries: [] } }, null, 2));
            }
          } catch (e) {
            chartHarCopy = null;
          }

        } catch (errChart) {
          note = `Error capturing chart for ${orderId}: ${errChart && errChart.message}`;
        } finally {
          chartResults.push({ orderId, chartScreenshot: chartShot, chartHar: chartHarCopy, note });
          try { await page.keyboard.press('Escape'); await sleep(500); } catch {}
        }
      }
    }

    // Close context (this will finalize the HAR file at tmpHar)
    await context.close().catch(() => {});
    await browser.close().catch(() => {});

    // Move the produced tmpHar to logs dir as final HAR (rename/copy)
    const harName = shotName.replace(/\.png$/, '.har');
    finalHarPath = path.join(PAGE_DIR, harName);
    if (fs.existsSync(tmpHar)) {
      try { fs.renameSync(tmpHar, finalHarPath); } catch { fs.copyFileSync(tmpHar, finalHarPath); try { fs.unlinkSync(tmpHar); } catch {} }
    } else {
      fs.writeFileSync(finalHarPath, JSON.stringify({ log: { entries: [] } }, null, 2));
    }

    const summary = {
      status,
      url: page.url(),
      rows: rowsFound,
      timestamp: new Date().toISOString(),
      reason,
      blotterScreenshot: finalScreenshotPath,
      blotterHar: finalHarPath,
      chartCaptures: chartResults
    };
    const jsonName = shotName.replace(/\.png$/, '.json');
    finalJsonPath = path.join(PAGE_DIR, jsonName);
    fs.writeFileSync(finalJsonPath, JSON.stringify(summary, null, 2));

    console.log(`${status === 'Success' ? '✅' : '❌'} ${status} — screenshot: ${finalScreenshotPath} har: ${finalHarPath} json: ${finalJsonPath}`);

    // Prepare attachments: always include blotter screenshot; on failure include har + json + chart artifacts
    try {
      const attachments = [];
      if (finalScreenshotPath && fs.existsSync(finalScreenshotPath)) attachments.push(finalScreenshotPath);

      if (status !== 'Success') {
        if (finalHarPath && fs.existsSync(finalHarPath)) attachments.push(finalHarPath);
        if (finalJsonPath && fs.existsSync(finalJsonPath)) attachments.push(finalJsonPath);
        // include chart artifacts if present
        for (const cr of chartResults) {
          if (cr.chartScreenshot && fs.existsSync(cr.chartScreenshot)) attachments.push(cr.chartScreenshot);
          if (cr.chartHar && fs.existsSync(cr.chartHar)) attachments.push(cr.chartHar);
        }
      }

      const subject = `Probe ${status}: ${PAGE_NAME}`;
      const bodyLines = [
        `Probe status: ${status}`,
        `Page: ${PAGE_NAME}`,
        `URL: ${page.url()}`,
        `Rows found: ${rowsFound}`,
        `Reason: ${reason}`,
        `Screenshot: ${finalScreenshotPath}`,
        `HAR: ${finalHarPath}`,
        `JSON summary: ${finalJsonPath}`,
        `Timestamp: ${new Date().toISOString()}`
      ];
      const body = bodyLines.join('\n');

      sendEmail(subject, body, attachments);
    } catch (e) {
      console.error('Email send attempt failed:', e && (e.message || e));
    }

    if (!success) process.exitCode = 2;
  } catch (err) {
    try { await context.close().catch(() => {}); } catch {}
    try { await browser.close().catch(() => {}); } catch {}
    const shotName = tsName('Failed', 'png');
    finalScreenshotPath = path.join(PAGE_DIR, shotName);
    await page.screenshot({ path: finalScreenshotPath, fullPage: true }).catch(() => {});
    finalHarPath = finalScreenshotPath.replace(/\.png$/, '.har');
    if (fs.existsSync(tmpHar)) {
      try { fs.renameSync(tmpHar, finalHarPath); } catch { try { fs.copyFileSync(tmpHar, finalHarPath); } catch {} try { fs.unlinkSync(tmpHar); } catch {} }
    }
    finalJsonPath = finalScreenshotPath.replace(/\.png$/, '.json');
    try { fs.writeFileSync(finalJsonPath, JSON.stringify({ status: 'Failed', error: err && (err.stack || err.message) }, null, 2)); } catch (e) {}

    console.error('Script error:', err && (err.stack || err.message));
    // attempt to send email with attachments (screenshot, har, json plus any chart results)
    try {
      const attachments = [];
      if (finalScreenshotPath && fs.existsSync(finalScreenshotPath)) attachments.push(finalScreenshotPath);
      if (finalHarPath && fs.existsSync(finalHarPath)) attachments.push(finalHarPath);
      if (finalJsonPath && fs.existsSync(finalJsonPath)) attachments.push(finalJsonPath);
      for (const cr of chartResults) {
        if (cr.chartScreenshot && fs.existsSync(cr.chartScreenshot)) attachments.push(cr.chartScreenshot);
        if (cr.chartHar && fs.existsSync(cr.chartHar)) attachments.push(cr.chartHar);
      }

      const subject = `Probe Error: ${PAGE_NAME}`;
      const body = [
        `Probe experienced an exception.`,
        `Error: ${err && (err.stack || err.message)}`,
        `Screenshot: ${finalScreenshotPath}`,
        `HAR: ${finalHarPath}`,
        `JSON: ${finalJsonPath}`,
        `Timestamp: ${new Date().toISOString()}`
      ].join('\n');

      sendEmail(subject, body, attachments);
    } catch (e) {
      console.error('Email send attempt failed in catch:', e && (e.message || e));
    }

    process.exitCode = 2;
  } finally {
    try { if (fs.existsSync(tmpHar)) fs.unlinkSync(tmpHar); } catch {}
  }
})();
