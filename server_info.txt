# server_info.py  â€” fixed without changing functionality

from __future__ import annotations

import base64
import io
import json
import os
import socket
from typing import Optional, List

import winrm
from fastapi import APIRouter, HTTPException
from fastapi.responses import StreamingResponse
from pydantic import BaseModel, constr, conint, validator

import re

# Pydantic constrained type aliases (avoid calling in annotations directly)
AppIdType = constr(strip_whitespace=True, min_length=1, max_length=64)
ServerNameType = constr(strip_whitespace=True, min_length=1, max_length=253)
UserNameType = constr(strip_whitespace=True, min_length=1, max_length=128)
PasswordType = constr(min_length=1, max_length=512)


# ---------- router ----------
router = APIRouter()


# ---------- helpers ----------

def ps_lit(s: str) -> str:
    """Make a safe single-quoted PowerShell literal."""
    if s is None:
        return ""
    # Convert to str and remove problematic control characters (keep printable only)
    s2 = str(s)
    # Replace any control chars (codepoints < 32 except tab/newline) with spaces
    s2 = "".join(ch if (ord(ch) >= 32 or ch in ['\t']) else ' ' for ch in s2)
    # Collapse newlines and carriage returns
    s2 = s2.replace('\r', ' ').replace('\n', ' ')
    # Escape single quotes by doubling them for PowerShell single-quoted strings
    s2 = s2.replace("'", "''")
    # Trim long values to a reasonable length to avoid huge command lines
    if len(s2) > 1024:
        s2 = s2[:1024]
    return s2


def ps_value_literal(v) -> str:
    """Return a PowerShell literal for a Python value (string, number, bool, None, list).

    Strings are single-quoted and escaped using ps_lit; booleans and None are returned
    as $true/$false/$null; numbers are returned as-is. Lists become @(...).
    """
    if v is None:
        return "$null"
    if isinstance(v, bool):
        return "$true" if v else "$false"
    if isinstance(v, (int, float)):
        return str(v)
    if isinstance(v, (list, tuple)):
        inner = ", ".join(ps_value_literal(x) for x in v)
        return "@(" + inner + ")"
    # fallback to string
    # Use single-quoted PowerShell literal
    return "'" + ps_lit(str(v)) + "'"


def read_script(script_name: str) -> str:
    """Read a PowerShell script from backend/scripts."""
    script_path = os.path.join(os.path.dirname(__file__), "..", "scripts", script_name)
    with open(script_path, encoding="utf-8") as f:
        return f.read()


def _clean_stdout(s: bytes | str) -> str:
    if not s:
        return ""
    if isinstance(s, bytes):
        s = s.decode(errors="replace")
    # Remove very long output to avoid memory/CPU issues
    MAX_OUT_CHARS = 1_000_000  # 1MB
    if len(s) > MAX_OUT_CHARS:
        s = s[:MAX_OUT_CHARS] + "\n...[TRUNCATED]"

    lines = s.splitlines()
    filtered = []
    for ln in lines:
        t = ln.strip()
        # remove CLIXML markers and common 'Preparing modules' progress messages
        if t.startswith("#< CLIXML"):
            continue
        if t.startswith("<Objs") or t.startswith("<Obj") or t.startswith("</Objs>"):
            continue
        if "Preparing modules for first use" in t:
            continue
        # remove non-printable characters from each line
        ln_clean = "".join(ch if ord(ch) >= 32 or ch == '\t' else ' ' for ch in ln)
        filtered.append(ln_clean)
    return "\n".join(filtered).strip()


def resolve_server_to_ip(server_name: str, app_id: str | None = None) -> str:
    # Try DNS/hosts resolution first
    try:
        return socket.gethostbyname(server_name)
    except Exception:
        pass
    # Fallback: look up in inventory
    inventory_path = os.path.join(os.path.dirname(__file__), "..", "app", "inventory.json")
    try:
        with open(inventory_path, encoding="utf-8") as f:
            inventory = json.load(f)
        if app_id and app_id in inventory:
            servers = inventory[app_id].get("servers", [])
        else:
            servers = [srv for app in inventory.values() for srv in app.get("servers", [])]
        for srv in servers:
            if srv.get("name", "").lower() == server_name.lower() and srv.get("ip"):
                return srv["ip"]
    except Exception:
        pass
    return server_name  # fallback to original name


def run_powershell_script_remote(
    server: str,
    username: str,
    password: str,
    script: str,
    app_id: str | None = None,
    params: dict | list | tuple | None = None,
):
    """Run a PowerShell script remotely via WinRM.

    If `params` is a list/tuple it will be passed as a positional ArgumentList to the
    remote ScriptBlock (safe quoting applied). If `params` is a dict it will be
    converted to named variable assignments that are prepended to the script; this keeps
    compatibility with scripts that expect pre-set variables.
    """
    target = resolve_server_to_ip(server, app_id)
    
    # Use simple NTLM authentication like the original working version
    try:
        session = winrm.Session(
            f'http://{target}:5985/wsman', 
            auth=(username, password), 
            transport='ntlm'
        )
    except Exception as e:
        raise Exception(f"Authentication failed for {target}: {str(e)}")
    
    try:

        # Build a safe script wrapper if params were provided
        script_to_run = script
        if params is not None:
            # Positional params -> use Invoke-Command -ArgumentList with a ScriptBlock
            if isinstance(params, (list, tuple)):
                arg_list = ", ".join(ps_value_literal(x) for x in params)
                script_to_run = (
                    f"$scriptBlock = [ScriptBlock]::Create(@'\n{script}\n'@); "
                    f"Invoke-Command -ScriptBlock $scriptBlock -ArgumentList {arg_list}"
                )
            elif isinstance(params, dict):
                # Named params -> prepend safe variable assignments
                prefix = "".join(f"${k} = {ps_value_literal(v)}; " for k, v in params.items())
                script_to_run = prefix + "\n" + script

        # If script is very large, upload it in chunks to a temp file on the remote host and execute that file.
        # This avoids WinRM/PowerShell command-line size limits that result in "The command line is too long." errors.
        MAX_INLINE = 3000
        try:
            if len(script_to_run) > MAX_INLINE:
                import uuid
                # remote temp paths
                rnd = uuid.uuid4().hex
                remote_b64 = f"C:\\Windows\\Temp\\wsops_b64_{rnd}.txt"
                remote_ps1 = f"C:\\Windows\\Temp\\wsops_script_{rnd}.ps1"

                # encode script as base64
                b64 = base64.b64encode(script_to_run.encode("utf-8")).decode("ascii")

                # ensure remote files are removed before starting
                try:
                    session.run_ps(f"if (Test-Path '{remote_b64}') {{ Remove-Item -Path '{remote_b64}' -Force }}; if (Test-Path '{remote_ps1}') {{ Remove-Item -Path '{remote_ps1}' -Force }}")
                except Exception:
                    pass

                # Use a simpler approach: create the base64 string in memory and write it directly
                # This avoids multiple Add-Content calls that can fail with command line length issues
                try:
                    # Split into manageable chunks and use PowerShell array concatenation
                    CHUNK = 2000  # Conservative chunk size
                    chunks = []
                    for i in range(0, len(b64), CHUNK):
                        chunk = b64[i : i + CHUNK]
                        chunk_escaped = chunk.replace("'", "''")
                        chunks.append(f"'{chunk_escaped}'")
                    
                    # Create array of chunks and join them, then write to file
                    chunks_array = "(" + ",".join(chunks) + ")"
                    write_cmd = f"$chunks = @{chunks_array}; ($chunks -join '') | Out-File -FilePath '{remote_b64}' -Encoding ascii -NoNewline"
                    
                    res_write = session.run_ps(write_cmd)
                    if getattr(res_write, 'status_code', 0) != 0:
                        # Fallback: try writing smaller chunks one by one with minimal commands
                        session.run_ps(f"'' | Out-File -FilePath '{remote_b64}' -Encoding ascii -NoNewline")  # create empty file
                        for i in range(0, len(b64), 1000):  # very small chunks
                            chunk = b64[i : i + 1000]
                            chunk_escaped = chunk.replace("'", "''")
                            append_cmd = f"Add-Content -Path '{remote_b64}' -Value '{chunk_escaped}' -Encoding ascii -NoNewline"
                            session.run_ps(append_cmd)
                        
                except Exception as upload_err:
                    raise Exception(f"Failed to upload script: {upload_err}")

                # decode base64 to script file and remove the b64 file
                decode_cmd = (
                    f"$b = Get-Content -Raw -Path '{remote_b64}'; "
                    f"[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($b)) | Out-File -FilePath '{remote_ps1}' -Encoding utf8; "
                    f"Remove-Item -Path '{remote_b64}' -Force"
                )
                session.run_ps(decode_cmd)

                # Execute the remote ps1 and capture output
                exec_res = session.run_ps(f"& '{remote_ps1}'")
                stdout = _clean_stdout(exec_res.std_out)
                stderr = _clean_stdout(exec_res.std_err)
                # cleanup the remote script file (best-effort)
                try:
                    session.run_ps(f"Remove-Item -Path '{remote_ps1}' -Force")
                except Exception:
                    pass
                return {"stdout": stdout, "stderr": stderr, "returncode": exec_res.status_code}
            else:
                result = session.run_ps(script_to_run)
                stdout = _clean_stdout(result.std_out)
                stderr = _clean_stdout(result.std_err)
                return {"stdout": stdout, "stderr": stderr, "returncode": result.status_code}
        except Exception as e:
            return {"stdout": "", "stderr": str(e), "returncode": -1}
    except Exception as e:
        return {"stdout": "", "stderr": str(e), "returncode": -1}


# ---------- models ----------

class ServerInfoRequest(BaseModel):
    # Basic fields; validators will enforce length and pattern constraints
    appId: str
    serverName: str
    username: str
    password: str

    @validator("appId")
    def appid_length(cls, v):
        if not v or len(v.strip()) == 0 or len(v) > 64:
            raise ValueError("appId length invalid")
        return v.strip()

    @validator("serverName")
    def validate_servername(cls, v):
        if not v or len(v.strip()) == 0 or len(v) > 253:
            raise ValueError("Invalid serverName length")
        if re.search(r"[;|>`$<\\]", v):
            raise ValueError("Invalid characters in serverName")
        ip_re = re.compile(r"^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$")
        host_re = re.compile(r"^[A-Za-z0-9._-]+(\.[A-Za-z0-9._-]+)*$")
        if not (ip_re.match(v) or host_re.match(v)):
            raise ValueError("serverName must be an IP or hostname")
        return v.strip()

    @validator("username")
    def username_length(cls, v):
        if not v or len(v.strip()) == 0 or len(v) > 128:
            raise ValueError("Invalid username length")
        return v.strip()

    @validator("password")
    def password_length(cls, v):
        if not v or len(v) == 0 or len(v) > 512:
            raise ValueError("Invalid password length")
        return v


class RegistryInfoRequest(ServerInfoRequest):
    registryPath: str

    @validator("registryPath")
    def registry_path_length(cls, v):
        if not v or len(v.strip()) == 0 or len(v) > 1024:
            raise ValueError("Invalid registryPath length")
        return v.strip()


class FolderInfoRequest(ServerInfoRequest):
    folderPath: str

    @validator("folderPath")
    def folder_path_length(cls, v):
        if not v or len(v.strip()) == 0 or len(v) > 2048:
            raise ValueError("Invalid folderPath length")
        return v.strip()


class ModifiedItemsRequest(BaseModel):
    appId: str
    serverName: str
    username: str
    password: str
    folderPath: str
    modifiedAfter: Optional[str] = None  # 'YYYY-MM-DD HH:mm:ss'
    modifiedBefore: Optional[str] = None
    recurse: bool = False
    maxItems: int = 500
    extensions: Optional[List[str]] = None

    @validator("appId")
    def mi_appid_length(cls, v):
        if not v or len(v.strip()) == 0 or len(v) > 64:
            raise ValueError("appId length invalid")
        return v.strip()

    @validator("serverName")
    def mi_validate_servername(cls, v):
        if not v or len(v.strip()) == 0 or len(v) > 253:
            raise ValueError("Invalid serverName length")
        if re.search(r"[;|>`$<\\]", v):
            raise ValueError("Invalid characters in serverName")
        return v.strip()

    @validator("username")
    def mi_username_length(cls, v):
        if not v or len(v.strip()) == 0 or len(v) > 128:
            raise ValueError("Invalid username length")
        return v.strip()

    @validator("password")
    def mi_password_length(cls, v):
        if not v or len(v) == 0 or len(v) > 512:
            raise ValueError("Invalid password length")
        return v

    @validator("folderPath")
    def mi_folder_path_length(cls, v):
        if not v or len(v.strip()) == 0 or len(v) > 2048:
            raise ValueError("Invalid folderPath length")
        return v.strip()


class WebConfigRequest(BaseModel):
    # used for /webconfig and /webconfig/download; appId optional for filename
    appId: Optional[str] = None
    serverName: str
    username: str
    password: str
    folderPath: str
    maxChars: int = 200000


class EventLogRequest(ServerInfoRequest):
    channel: str = "System"  # System | Application | Security
    hours: int = 24
    startTime: Optional[str] = None  # ISO datetime string
    endTime: Optional[str] = None
    maxEvents: int = 200



# ---------- routes ----------

@router.post("/api/server/registryinfo")
def get_registry_info(req: RegistryInfoRequest):
    # Block top-level keys for performance and safety
    top_level_keys = {
        "HKLM", "HKEY_LOCAL_MACHINE",
        "HKCU", "HKEY_CURRENT_USER",
        "HKCR", "HKEY_CLASSES_ROOT",
        "HKU", "HKEY_USERS",
        "HKCC", "HKEY_CURRENT_CONFIG",
        "SYSTEM"
    }

    # Normalize path and ensure Registry:: prefix for PowerShell
    path = (req.registryPath or "").strip().replace("/", "\\")

    # Accept inputs like 'HKLM\\SOFTWARE\\...' or 'HKEY_LOCAL_MACHINE\\SOFTWARE\\...'
    # Normalize short aliases to full hive names (PowerShell accepts Registry::HKEY_...)
    alias_map = {
        "HKLM": "HKEY_LOCAL_MACHINE",
        "HKCU": "HKEY_CURRENT_USER",
        "HKCR": "HKEY_CLASSES_ROOT",
        "HKU": "HKEY_USERS",
        "HKCC": "HKEY_CURRENT_CONFIG",
    }

    raw = path
    # If user provided 'Registry::...' keep as-is
    if raw.lower().startswith("registry::"):
        path_with_prefix = raw
    else:
        parts = [p for p in raw.split("\\") if p != ""]
        if parts:
            root = parts[0].upper().rstrip(":")
            rest = "\\".join(parts[1:]) if len(parts) > 1 else ""
            if root in alias_map:
                root_full = alias_map[root]
                path_with_prefix = f"Registry::{root_full}\\{rest}" if rest else f"Registry::{root_full}"
            elif root.startswith("HKEY_"):
                path_with_prefix = f"Registry::{raw}"
            elif root.endswith(":"):
                # e.g., 'HKLM:' style -> convert 'HKLM:\SOFTWARE' to HKEY name
                root_key = root.rstrip(":").upper()
                if root_key in alias_map:
                    root_full = alias_map[root_key]
                    path_with_prefix = f"Registry::{root_full}\\{rest}"
                else:
                    path_with_prefix = f"Registry::{raw}"
            else:
                # Unknown root; pass through with Registry:: prefix and hope for the best
                path_with_prefix = f"Registry::{raw}"
        else:
            path_with_prefix = f"Registry::{raw}"

    # Depth guard: require deeper than top-level root\something
    raw_no_prefix = path_with_prefix.replace("Registry::", "")
    parts = [p for p in raw_no_prefix.split("\\") if p != ""]
    if parts:
        root = parts[0].upper()
        if root in top_level_keys and len(parts) <= 2:
            # e.g., HKLM or HKLM\SOFTWARE â€” too broad
            return {
                "AppID": req.appId,
                "Server": req.serverName,
                "Items": [],
                "stderr": "Top-level registry queries are not allowed.",
                "returncode": -2,
            }

    # Read external PowerShell script and call it with the raw path as a positional arg
    script = read_script("get_registry_info.ps1")
    params = [raw_no_prefix]
    result = run_powershell_script_remote(req.serverName, req.username, req.password, script, req.appId, params=params)
    return {
        "AppID": req.appId,
        "Server": req.serverName,
        "RawOutput": result.get("stdout", ""),
        "stderr": result.get("stderr", ""),
        "returncode": result.get("returncode", 0),
    }



# Updated: Parse stdout and return {rows: [...], stderr: ...}
@router.post("/api/server/iis")
def get_iis_info(req: ServerInfoRequest):
    script = read_script("get_iis_websites.ps1")
    result = run_powershell_script_remote(req.serverName, req.username, req.password, script, req.appId)
    try:
        stdout = result.get("stdout", "")
        rows = json.loads(stdout) if stdout else []
        if isinstance(rows, dict):
            rows = [rows]
    except Exception as e:
        rows = []
        result["stderr"] = f"Failed to parse IIS websites output: {e}"
    return {
        "rows": rows,
        "stderr": result.get("stderr", ""),
        "returncode": result.get("returncode", 0),
    }


@router.post("/api/server/os_patching_parallel")
def get_server_health_info(req: dict):
    """Return Server Health Info from multiple servers in parallel using ThreadPoolExecutor.
    
    Checks OS version, uptime, stopped services, IIS websites, and app pools.
    
    Expected payload:
    {
        "servers": [{"appId": "1001", "serverName": "server1", "username": "user", "password": "pass"}, ...]
    }
    """
    import concurrent.futures
    
    servers = req.get("servers", [])
    if not servers:
        return {"results": []}
    
    script = read_script("get_os_patching_info.ps1")
    
    def process_single_server(server_config):
        """Process a single server and return health info result"""
        try:
            appId = server_config.get("appId")
            serverName = server_config.get("serverName")
            username = server_config.get("username")
            password = server_config.get("password")
            
            result = run_powershell_script_remote(serverName, username, password, script, appId)
            
            try:
                stdout = result.get("stdout", "")
                rows = json.loads(stdout) if stdout else []
                if isinstance(rows, dict):
                    rows = [rows]
            except Exception as e:
                rows = []
                result["stderr"] = f"Failed to parse server health info output: {e}"
            
            return {
                "appId": appId,
                "server": serverName,
                "rows": rows,
                "stderr": result.get("stderr", ""),
                "returncode": result.get("returncode", 0),
            }
        except Exception as e:
            return {
                "appId": server_config.get("appId"),
                "server": server_config.get("serverName"),
                "rows": [],
                "stderr": str(e),
                "returncode": 1,
            }
    
    # Use ThreadPoolExecutor for parallel execution (max 15 concurrent connections)
    with concurrent.futures.ThreadPoolExecutor(max_workers=15) as executor:
        results = list(executor.map(process_single_server, servers))
    
    return {"results": results}


@router.post("/api/server/parallel")
def execute_parallel_operation(req: dict):
    """Universal parallel execution endpoint for all server operations.
    
    Expected payload:
    {
        "operation": "services|servicepacks|iis|gac|comobjects|certificates|eventlogs|registryinfo",
        "servers": [{"appId": "1001", "serverName": "server1", "username": "user", "password": "pass"}, ...],
        "params": {...}  // Optional operation-specific parameters
    }
    """
    import concurrent.futures
    
    operation = req.get("operation")
    servers = req.get("servers", [])
    operation_params = req.get("params", {})
    
    if not operation or not servers:
        return {"results": []}
    
    # Operation to script mapping
    script_mapping = {
        "services": "get_services.ps1",
        "servicepacks": "get_servicepacks.ps1", 
        "iis": "get_iis_websites.ps1",
        "gac": "get_gac_assemblies.ps1",
        "comobjects": "get_com_objects.ps1",
        "certificates": "get_certificates.ps1",
        "eventlogs": "query_eventlog.ps1",
        "registryinfo": "get_registry_info.ps1"
    }
    
    script_file = script_mapping.get(operation)
    if not script_file:
        return {"results": [], "error": f"Unknown operation: {operation}"}
    
    script = read_script(script_file)
    
    def process_single_server(server_config):
        """Process a single server and return result"""
        try:
            appId = server_config.get("appId")
            serverName = server_config.get("serverName")
            username = server_config.get("username")
            password = server_config.get("password")
            
            # Handle operation-specific parameters
            if operation == "registryinfo":
                registry_path = operation_params.get("registryPath", "")
                # Use positional parameters for param() block in PowerShell script
                params = [registry_path]  # Pass registry path as positional parameter
                result = run_powershell_script_remote(serverName, username, password, script, appId, params=params)
                
                # Registry info returns text output, not JSON
                return {
                    "appId": appId,
                    "server": serverName,
                    "operation": operation,
                    "data": result.get("stdout", ""),  # Return raw text output
                    "stderr": result.get("stderr", ""),
                    "returncode": result.get("returncode", 0),
                }
            elif operation == "eventlogs":
                # Use positional parameters for param() block in PowerShell script
                # param($Channel, $Hours, $StartTime, $EndTime, $MaxEvents)
                channel = operation_params.get("logName", "Application")
                hours = 24  # Default value since we don't use hours in parallel execution
                start_time = operation_params.get("startTime", "")
                end_time = operation_params.get("endTime", "")
                max_events = int(operation_params.get("maxEvents", 200))
                
                params = [channel, hours, start_time, end_time, max_events]
                result = run_powershell_script_remote(serverName, username, password, script, appId, params=params)
                
                try:
                    stdout = result.get("stdout", "")
                    data = json.loads(stdout) if stdout else []
                    if isinstance(data, dict):
                        data = [data]
                except Exception as e:
                    data = []
                    result["stderr"] = f"Failed to parse {operation} output: {e}"
                
                return {
                    "appId": appId,
                    "server": serverName,
                    "operation": operation,
                    "data": data,
                    "stderr": result.get("stderr", ""),
                    "returncode": result.get("returncode", 0),
                }
            else:
                params = {"AppID": appId, "Server": serverName}
                
                result = run_powershell_script_remote(serverName, username, password, script, appId, params=params)
                
                try:
                    stdout = result.get("stdout", "")
                    data = json.loads(stdout) if stdout else []
                    if isinstance(data, dict):
                        data = [data]
                except Exception as e:
                    data = []
                    result["stderr"] = f"Failed to parse {operation} output: {e}"
                
                return {
                    "appId": appId,
                    "server": serverName,
                    "operation": operation,
                    "data": data,
                    "stderr": result.get("stderr", ""),
                    "returncode": result.get("returncode", 0),
                }
        except Exception as e:
            return {
                "appId": server_config.get("appId"),
                "server": server_config.get("serverName"),
                "operation": operation,
                "data": [],
                "stderr": str(e),
                "returncode": 1,
            }
    
    # Use ThreadPoolExecutor for parallel execution (max 15 concurrent connections)
    with concurrent.futures.ThreadPoolExecutor(max_workers=15) as executor:
        results = list(executor.map(process_single_server, servers))
    
    return {"results": results}


    return {"results": results}


@router.post("/api/server/iis_apppools_parallel")
def get_iis_apppools_parallel(req: dict):
    """Get IIS Application Pools from multiple servers in parallel."""
    import concurrent.futures
    
    servers = req.get("servers", [])
    if not servers:
        return {"results": []}
    
    script = read_script("get_iis_apppools.ps1")
    
    def process_single_server(server_config):
        """Process a single server for IIS App Pools"""
        try:
            appId = server_config.get("appId")
            serverName = server_config.get("serverName")
            username = server_config.get("username")
            password = server_config.get("password")
            
            params = {"AppID": appId, "Server": serverName}
            result = run_powershell_script_remote(serverName, username, password, script, appId, params=params)
            
            try:
                stdout = result.get("stdout", "")
                data = json.loads(stdout) if stdout else []
                if isinstance(data, dict):
                    data = [data]
            except Exception as e:
                data = []
                result["stderr"] = f"Failed to parse IIS App Pools output: {e}"
            
            return {
                "appId": appId,
                "server": serverName,
                "data": data,
                "stderr": result.get("stderr", ""),
                "returncode": result.get("returncode", 0),
            }
        except Exception as e:
            return {
                "appId": server_config.get("appId"),
                "server": server_config.get("serverName"),
                "data": [],
                "stderr": str(e),
                "returncode": 1,
            }
    
    # Use ThreadPoolExecutor for parallel execution (max 15 concurrent connections)
    with concurrent.futures.ThreadPoolExecutor(max_workers=15) as executor:
        results = list(executor.map(process_single_server, servers))
    
    return {"results": results}


@router.post("/api/server/content_verification_parallel")
def get_content_verification_parallel(req: dict):
    """Get Modified Items (Content Verification) from multiple servers in parallel."""
    import concurrent.futures
    
    servers = req.get("servers", [])
    modified_items_path = req.get("modified_items_path", "")
    modified_after = req.get("modified_after", "")
    modified_before = req.get("modified_before", "")
    recurse = req.get("recurse", False)
    max_items = req.get("max_items", 500)
    
    if not servers:
        return {"results": []}
    
    script = read_script("get_modified_items.ps1")
    
    def process_single_server(server_config):
        """Process a single server for Modified Items"""
        try:
            appId = server_config.get("appId")
            serverName = server_config.get("serverName")
            username = server_config.get("username")
            password = server_config.get("password")
            
            # Format dates for PowerShell if provided
            formatted_after = None
            formatted_before = None
            
            if modified_after:
                try:
                    # Convert from frontend datetime-local format to PowerShell datetime
                    from datetime import datetime
                    dt_after = datetime.fromisoformat(modified_after.replace('T', ' '))
                    formatted_after = dt_after.strftime('%Y-%m-%d %H:%M:%S')
                except:
                    formatted_after = None
            
            if modified_before:
                try:
                    from datetime import datetime
                    dt_before = datetime.fromisoformat(modified_before.replace('T', ' '))
                    formatted_before = dt_before.strftime('%Y-%m-%d %H:%M:%S')
                except:
                    formatted_before = None
            
            params = {
                "AppID": appId, 
                "Server": serverName, 
                "FolderPath": modified_items_path,
                "MaxItems": max_items,
                "Recurse": recurse,
                "ModifiedAfter": formatted_after,
                "ModifiedBefore": formatted_before,
                "Extensions": []  # Empty for now, can be added later if needed
            }
            result = run_powershell_script_remote(serverName, username, password, script, appId, params=params)
            
            try:
                stdout = result.get("stdout", "")
                data = json.loads(stdout) if stdout else []
                if isinstance(data, dict):
                    data = [data]
            except Exception as e:
                data = []
                result["stderr"] = f"Failed to parse Modified Items output: {e}"
            
            return {
                "appId": appId,
                "server": serverName,
                "data": data,
                "stderr": result.get("stderr", ""),
                "returncode": result.get("returncode", 0),
            }
        except Exception as e:
            return {
                "appId": server_config.get("appId"),
                "server": server_config.get("serverName"),
                "data": [],
                "stderr": str(e),
                "returncode": 1,
            }
    
    # Use ThreadPoolExecutor for parallel execution (max 15 concurrent connections)
    with concurrent.futures.ThreadPoolExecutor(max_workers=15) as executor:
        results = list(executor.map(process_single_server, servers))
    
    return {"results": results}


@router.post("/api/server/webconfig_parallel")
def get_webconfig_parallel(req: dict):
    """Get Web Config information from multiple servers in parallel."""
    import concurrent.futures
    
    servers = req.get("servers", [])
    webconfig_path = req.get("webconfig_path", "")
    
    if not servers:
        return {"results": []}
    
    script = read_script("get_webconfig.ps1")
    
    def process_single_server(server_config):
        """Process a single server for Web Config"""
        try:
            appId = server_config.get("appId")
            serverName = server_config.get("serverName")
            username = server_config.get("username")
            password = server_config.get("password")
            
            # Use positional parameters for param() block in PowerShell script
            params = [webconfig_path]  # Only pass the folder path as positional parameter
            result = run_powershell_script_remote(serverName, username, password, script, appId, params=params)
            
            try:
                stdout = result.get("stdout", "")
                data = json.loads(stdout) if stdout else []
                if isinstance(data, dict):
                    data = [data]
            except Exception as e:
                data = []
                result["stderr"] = f"Failed to parse Web Config output: {e}"
            
            return {
                "appId": appId,
                "server": serverName,
                "data": data,
                "stderr": result.get("stderr", ""),
                "returncode": result.get("returncode", 0),
            }
        except Exception as e:
            return {
                "appId": server_config.get("appId"),
                "server": server_config.get("serverName"),
                "data": [],
                "stderr": str(e),
                "returncode": 1,
            }
    
    # Use ThreadPoolExecutor for parallel execution (max 15 concurrent connections)
    with concurrent.futures.ThreadPoolExecutor(max_workers=15) as executor:
        results = list(executor.map(process_single_server, servers))
    
    return {"results": results}


# Alias to match frontend `/api/server/iis/websites` without breaking existing route
@router.post("/api/server/iis/websites")
def get_iis_websites_alias(req: ServerInfoRequest):
    return get_iis_info(req)


@router.post("/api/server/services")
def get_services_info(req: ServerInfoRequest):
    # Pass appId and serverName as named parameters (they will be prepended safely)
    script = read_script("get_services.ps1")
    params = {"AppID": req.appId, "Server": req.serverName}
    result = run_powershell_script_remote(req.serverName, req.username, req.password, script, req.appId, params=params)
    try:
        stdout = result.get("stdout", "")
        services = json.loads(stdout) if stdout else []
        if isinstance(services, dict):
            services = [services]
        services_list = [
            {
                "Name": s.get("Name", ""),
                "DisplayName": s.get("DisplayName", ""),
                "State": s.get("State", ""),
                "StartMode": s.get("StartMode", ""),
                "StartName": s.get("StartName", ""),
            }
            for s in services
        ]
        return {
            "AppID": req.appId,
            "Server": req.serverName,
            "services": services_list,
            "stderr": result.get("stderr", ""),
            "returncode": result.get("returncode", 0),
        }
    except Exception as e:
        return {
            "AppID": req.appId,
            "Server": req.serverName,
            "services": [],
            "stderr": str(e),
            "returncode": -1,
        }


@router.post("/api/server/servicepacks")
def get_servicepacks_info(req: ServerInfoRequest):
    script = read_script("get_servicepacks.ps1")
    result = run_powershell_script_remote(req.serverName, req.username, req.password, script, req.appId)
    stdout = result.get("stdout", "") or ""
    stderr = result.get("stderr", "") or ""
    installed = []
    hotfixes = []
    parseError = False
    try:
        parsed = json.loads(stdout) if stdout else {}
        if isinstance(parsed, dict):
            installed = parsed.get("InstalledSoftware") or []
            hotfixes = parsed.get("HotFixes") or []
        elif isinstance(parsed, list):
            # Older scripts might return a bare list of software; treat as InstalledSoftware
            installed = parsed
    except Exception:
        # leave arrays empty and flag parse error
        parseError = True

    # Normalize to lists
    if not isinstance(installed, list):
        installed = [installed] if installed else []
    if not isinstance(hotfixes, list):
        hotfixes = [hotfixes] if hotfixes else []

    return {
        "AppID": req.appId,
        "Server": req.serverName,
        "InstalledSoftware": installed,
        "HotFixes": hotfixes,
        "RawOutput": stdout,
        "parseError": parseError,
        "stderr": stderr,
        "returncode": result.get("returncode", 0),
    }



# Updated: Parse stdout and return {rows: [...], stderr: ...}
@router.post("/api/server/iisapppools")
def get_iis_apppools(req: ServerInfoRequest):
    script = read_script("get_iis_apppools.ps1")
    result = run_powershell_script_remote(req.serverName, req.username, req.password, script, req.appId)
    try:
        stdout = result.get("stdout", "")
        rows = json.loads(stdout) if stdout else []
        if isinstance(rows, dict):
            rows = [rows]
    except Exception as e:
        rows = []
        result["stderr"] = f"Failed to parse IIS app pools output: {e}"
    return {
        "rows": rows,
        "stderr": result.get("stderr", ""),
        "returncode": result.get("returncode", 0),
    }


# Alias to match frontend `/api/server/iis/apppools`
@router.post("/api/server/iis/apppools")
def get_iis_apppools_alias(req: ServerInfoRequest):
    return get_iis_apppools(req)


@router.post("/api/server/modifieditems")
def get_modified_items(req: ModifiedItemsRequest):
    if req.maxItems <= 0 or req.maxItems > 5000:
        raise HTTPException(status_code=400, detail="maxItems out of allowed range (1..5000)")

    # Use named params to safely pass folderPath, limits, and date strings
    script = read_script("get_modified_items.ps1")
    # Convert extensions to list or null
    params = {
        "AppID": req.appId,
        "Server": req.serverName,
        "FolderPath": req.folderPath,
        "MaxItems": int(req.maxItems),
        "Recurse": bool(req.recurse),
        "ModifiedAfter": req.modifiedAfter or None,
        "ModifiedBefore": req.modifiedBefore or None,
        "Extensions": req.extensions or [],
    }
    return run_powershell_script_remote(req.serverName, req.username, req.password, script, req.appId, params=params)


@router.post("/api/server/webconfig")
def get_webconfig(req: WebConfigRequest):
    # Escape and quote folder path for PowerShell
    folder = ps_lit(req.folderPath).rstrip("\\/ ").strip()
    folder_literal = f"'{folder}'"  # Always wrap in single quotes
    maxchars = int(req.maxChars)
    ps_script_content = read_script("get_webconfig.ps1")
    # The get_webconfig.ps1 uses a param($FolderPath) declaration so call it via positional args
    script = ps_script_content
    # Pass folder and maxchars as positional args to the remote ScriptBlock
    params = [req.folderPath, maxchars]
    return run_powershell_script_remote(req.serverName, req.username, req.password, script, req.appId, params=params)


@router.post("/api/server/gac")
def get_gac_assemblies(req: ServerInfoRequest):
    script = read_script("get_gac_assemblies.ps1")
    result = run_powershell_script_remote(req.serverName, req.username, req.password, script, req.appId)
    # Wrap stdout in Items property if possible
    try:
        items = json.loads(result.get("stdout", "[]"))
        if not isinstance(items, list):
            items = []
    except Exception:
        items = []
    result["Items"] = items
    return result


@router.post("/api/server/comobjects")
def get_com_objects(req: ServerInfoRequest):
    script = read_script("get_com_objects.ps1")
    result = run_powershell_script_remote(req.serverName, req.username, req.password, script, req.appId)
    # Wrap stdout in Items property if possible
    try:
        items = json.loads(result.get("stdout", "[]"))
        if not isinstance(items, list):
            items = []
    except Exception:
        items = []
    result["Items"] = items
    return result


@router.post("/api/server/certificates")
def get_certificates(req: ServerInfoRequest):
    """Collect certificates from common stores and return Items list.
    Each item should include: Subject, Issuer, Thumbprint, Store, NotBefore, NotAfter, Valid
    """
    script = read_script("get_certificates.ps1")
    result = run_powershell_script_remote(req.serverName, req.username, req.password, script, req.appId)
    # Try to parse JSON Items from stdout
    try:
        items = json.loads(result.get("stdout", "[]"))
        if not isinstance(items, list):
            items = []
    except Exception:
        items = []
    return {
        "AppID": req.appId,
        "Server": req.serverName,
        "Items": items,
        "stderr": result.get("stderr", ""),
        "returncode": result.get("returncode", 0),
    }


@router.post("/api/server/eventlogs")
def query_event_logs(req: EventLogRequest):
    script = read_script("query_eventlog.ps1")
    params = [req.channel, int(req.hours or 24), req.startTime or "", req.endTime or "", int(req.maxEvents or 200)]
    result = run_powershell_script_remote(req.serverName, req.username, req.password, script, req.appId, params=params)
    stdout = result.get("stdout", "") or ""
    stderr = result.get("stderr", "") or ""
    events = []
    error_msg = None
    raw_output = None
    try:
        parsed = json.loads(stdout) if stdout else []
        if isinstance(parsed, list):
            events = parsed
        elif isinstance(parsed, dict):
            # Script returned an object: either an error payload or a single-event dict
            if parsed.get("Error"):
                error_msg = parsed.get("Error")
            else:
                # wrap single object as list
                events = [parsed]
    except Exception:
        # If parsing fails, keep raw output for debugging but still return normalized shape
        raw_output = stdout

    resp = {
        "AppID": req.appId,
        "Server": req.serverName,
        "Events": events,
        "stderr": stderr,
        "returncode": result.get("returncode", 0),
    }
    if error_msg:
        resp["Error"] = error_msg
    if raw_output:
        resp["RawOutput"] = raw_output

    return resp


@router.post("/api/server/webconfig/download")
def download_webconfig(req: WebConfigRequest):
    import datetime
    folder = ps_lit(req.folderPath).rstrip("\\/ ").strip()
    folder_literal = f"'{folder}'"
    ps_script_content = read_script("get_webconfig.ps1")
    script = ps_script_content
    params = [req.folderPath, int(req.maxChars)]
    result = run_powershell_script_remote(req.serverName, req.username, req.password, script, req.appId, params=params)
    try:
        data = json.loads(result.get("stdout", "") or "{}")
    except Exception:
        raise HTTPException(status_code=500, detail="Invalid response from remote server")

    if not data.get("WebConfigBase64"):
        raise HTTPException(status_code=404, detail=data.get("Error") or "web.config not found")

    # Support both base64 and 0x... hex payloads
    file_bytes = io.BytesIO()
    b64 = data["WebConfigBase64"]
    if isinstance(b64, str) and b64.startswith("0x"):
        try:
            file_bytes.write(bytes.fromhex(b64[2:]))
        except Exception:
            raise HTTPException(status_code=500, detail="Invalid hex payload from remote server")
    else:
        try:
            file_bytes.write(base64.b64decode(b64))
        except Exception:
            raise HTTPException(status_code=500, detail="Invalid base64 payload from remote server")
    file_bytes.seek(0)

    # Sanitize filename parts and enforce size limit
    def _sanitize_filename_part(s: str, maxlen: int = 64) -> str:
        if not s:
            return "unknown"
        s2 = str(s)
        # Replace unsafe chars with underscore
        s2 = re.sub(r"[^A-Za-z0-9._-]", "_", s2)
        return s2[:maxlen]

    appid_safe = _sanitize_filename_part(req.appId or "unknownapp")
    server_safe = _sanitize_filename_part(req.serverName or "unknownserver")
    now = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"{appid_safe}_{server_safe}_webconfig_{now}.config"

    # Enforce max file size for downloads (5 MB)
    MAX_DOWNLOAD_BYTES = 5 * 1024 * 1024
    file_bytes.seek(0, io.SEEK_END)
    size = file_bytes.tell()
    if size > MAX_DOWNLOAD_BYTES:
        raise HTTPException(status_code=413, detail="Requested web.config payload too large")
    file_bytes.seek(0)

    return StreamingResponse(
        file_bytes,
        media_type="application/xml",
        headers={"Content-Disposition": f'attachment; filename="{filename}"'},
    )
